#+TITLE: Python notes

* Dive into Python
** Chapter 1
+ Notes: All functions return something if not specified in the function than return value will be none
  no explicit types...
+ Function arguments can be in any order as long as they are named. Once a named argument is used all further arguments must be named.
+ Docstrings: A triple quote starts (and stops) a multiline comment - such as a doc string, They may contain single and double quotes. A docstring if it exists must be the first thing defined in a function - it must start on the first line after the declaration. The docstring is also available at runtime as an attribute of the function.  Also used by IDE's for tooltips.
+ Import search path: search path is a list defined in sys.path. New directories can be added at runtime by adding the directory name to sys.path - sys.path.insert(0 new_path) inserts a new directory as the first item in the list (directories are searched in the order they appear until a .py file whith a name that matches the import statement is found)
+ Once a .py file is imported as a module any of its public functions, classes or attributes are available to other modules or interactively through the REPL
+ when calling a function use moduleName.Function
+ Python functions (like everything else in Python) are objects and have attributes that are available at runtime.
+ Objects in python do not need to have attributes or methods - not all objects are subclassable. Everything is an object in the sense that it can be assigned to a variable or passed as an argument to a function.
+ In Python functions are first class objects and can be passed  as argument to other functions. Modules and classes (or instances of a class) as well
+ Is this the same sort of flexibility that allow for meta-programming in LISP?
+ Indenting code: Instead of using punctuation marks to mark out blocks of code Python uses indentation... Whitespace use must be consistent...
+ Exceptions: Instead of using return codes to indicate errors. Python uses exceptions that once raised need to be handled. Unhandled exceptions will cause a programs execution to halt. Functions dont declare which exceptions may be raised. Not all exceptions are errors - some are fairly easy to anticipate (like a file not opening because it does not exist yet)
+ If a line of code is likely to raise an exception use a try-except block. Use raise statement to generate exceptions.
+ raise statement myExceptionName('optional human readable debugging info') - this creates an instance of the ValueError class and passing the string to its initialization method.
+ Exceptions that are not handled in the function that raises it are passed to the calling function until handled or the program crashes and Python prints a traceback error.
+ One common built in exception is the ImportError - handling it provide a way to have the features of a program gracefully degrade if certain libraries will only be available in certain circumstances.
  #+BEGIN_SRC python
    try:
        import chardet
    except ImportError:
        chardet = None

    if chardet:
        # code based on having chardet librqary
    else:
        # the rest of the program
  #+END_SRC

  #+RESULTS:

  This exception can also be used when there are multiple modules that implement an API to allow one to be used only if the other one is not available without needing to have further code to determine which version was imported.
+ Everything in Python is case sensitive.
+ Modules have several built in attributes. if a module is imported __name__ will be the modules filename (without path info or extension) if the module is run as a standalone __name__ will default to __main__ This can be used for unit testing

** Chapter 2 - datatypes
1. Boolean
2. Numbers: can be integers fractions, floats, or complex
3. Strings: sequence of unicode characters
4. Bytes and byte arrays: binary files etc
5. Lists: ordered sequence of values
6. Tuples: orderd immutable sequence of values
7. Set: unordered collection of values
8. Dictionaries: unordered collection of key-value pairs.
Plus lots of other stuff since everything is an object in Python.
+ Boolean 0 = false every other number evaluates to true
*** Lists : Workhorse of basic Python. Can expand dynamically
   - a_list = ['a', 'b', 'c', 'foo']
   - a_list[0]= 'a'
   - lists can be sliced a_list[1:2] returns ['b'] the first number is the number to start with and the second is the number to stop before.
     - If an indice is the first or last item it can be left out: a_list[:] returns a copy of the entire list. The copy is a new list and therefore is not the same as the a_list variable despite having the same values
     - a_list[:-1] returns everything but the last element a_list[1:] returns every element excluding the first
   - Adding items to a list
     - the + operator concatenates two lists to create a new list that is immediately assigned to the existing list so
       #+BEGIN_SRC python
       my_list = ['a']
       my_list = my_list + ['b', 'c', 4.0, 5]
       #+END_SRC
       Produces my_list['a', 'b', 'c', 4.0, 5]
     - my_list.append(True) would add true to the end of the list. The append method takes a single argument of any data type and adds it to the end of the list. If you append with a list as the aargument the entire list will be added as a single item (creating amultidimensional list)
     - my_list.extend(['moreValues', 'False']) will add two more values to the list. Extend takes a list as an argument and adds each item to the list that called it.
     - my_list.insert(3, 'a') would insert 'a' into the list at the 4th position because list items do not need to be unique my_list would be ['a', 'b', 'c', 'a', 4.0, 5, True, 'moreValues', False]
     - Lists are an implemented as classes so append,extend, and insert, are methods that operate on a list
   - Searching for values in a list
     - my_list.count(True) would return the number of times the value True appear in my_list. The index method returns the index of the first occurrence. The index method can also take a second argument that indicates the index to start searching and a third argument of the index to stop searching. This can allow you to find the index of occurrences of a value other than the first one
     - a in my_list would return True
     - if you call index and the value does not occur in the list you will get an exception raised
   - Removing items from a list
     - del my_list[1] removes the second item from a list. The third item will then become the second (or if there is no third the list will be of size 1)
     - my_list.remove('c') will remove the first occurrence of the item 'c' from my_list or raise an exception if the value does not exist.
     - my_list.pop() will remove the last item from my_list and return the value that it removed
     - can also be used with the index of the item to remove
     - pop will raise an exception if called on an empty list
   - Lists in a Boolean context
     - empty lists evaluate to false
     - a list with at least one item is true - even if the value is False.
*** Tuples
A tuple is an immutable list, so great for functional programming. my_tuple = ("I", "love", "clojure", "True", 42, 23, 93)
+ Tuple are ordered and have 0 based indices
+ a negative index indicates counting from the end of the tuple
+ slicing a tuple produces a new tuple - my_tuple[1:3] returns ("love", "clojure")
+ tuples have no methods that allow their values to change. you can use index or search using "I" in my_tuple
+ tuples are faster than lists. They are read only so are safer than lists.
+ Some tuples can be used as dictionary keys (tuples that contain immutable values like strings, numbers, or other tuples) Since dictionary keys must be immutable lists dont work
+ The tuple() function takes a list and returns a tuple. The list() function takes a tuple and returns a list
+ To create a tuple of one item you need to put a comma after the item or else python will ignore the parentheses so type((False)) returns bool while type((False,)) returns tuple
+ Tuples can be used to assign multiple values at once. t = (1, '1', 2, 3.0)
  (var1, var2, var3, var4) = t results in var1 being equal to 1 var2 being equal to '1' and so on
+ you can use tuples to have a function return multiple values and either have the caller keep the values in a tuple or break them out into individual variables, or make a list for that matter

*** Sets
A set is an unordered collection of unique values of any immutable datatype. With two sets you can do set operations like union, intersection, and set difference.
+ Creating a set my_set{1, 2, 'a', True}
+ my_other_set = set(my_list) creates a set from my_list
+ you can create an empty set a_set = set()
+ the empty set is represented by set() {} is a dictionary for some reason... so not_a_set = {} creates am empty dictionary
+ my_set.add(3) will add 3 to my_set. my_set.add(1) will do nothing as a set is made up of unique values so adding an existing value does not create multiple occurrences
+ my_set.update() takes an argument of a set and adds each member to the calling set.
+ the update method can actually be called with multiple sets and will combine all the values with the ones from the original set
+ update can be used with lists as well
+ removing items from a set - discard method takes a single value and removes it from a set If the value is not part of the set it is a no-op (does not raise an exception)
+ remove also takes a value out of a set but raises an error if the value was not part of the set
+ pop method will remove a random value from a set and returns it. Since sets are unordered there is no way of predicting which value will be removed. If pop is called on an empty set it raises an exception
+ clear method removes all values so you end up with an empty set. clear is equivalent to taking a_set_with_some_values = set() which overwrites the previous values with an empty set
+ someValue in a_set return true if the value is in the set
+ a_set.union(b_set) returns a set with the values from both sets.(either set)
+ a_set.intersection(b_set) returns a set of the common values that are in both sets
+ a_set.difference(b_set) returns a  new set with elements that are members of a that are not in b
+ a_set.symmetric_difference(b_set) returns a new set that contain elements that were in exactly one of the sets.
+ a_set.issubset(b_set) returns true is all elements in a are also in b
+ b_set.issuperset(a_set) reverse of above
+ boolean value of an empty set is False, other sets (ones with at least one element) are True. Value of the elements does not matter.... so a set that contains the string False and nothing else will evaluate to true.
*** Dictionaries
- Unordered
- key value pairs.
- when a key is added it must also have a value
- optimized for using the key to find the value, but not good at finding the key when you know the value.
- Acts like a hash in Perl 5
**** Creating a dictionary
+ my_dict = {'server': 'db.diveintopython3.org', 'database': 'mysql'}
+ you can't look up keys from the value.
+ no predefined size limit you can add new key-value pairs and you can modify the value of an existing ey
+ you can't have duplicate keys
+ dictionaries are unordered
+ keys are case sensitive so User != user
+ Dictionaries values can be any datatype including other dictionaries.
+ dictionary keys are more restrictied they can be strings integers and a few other types. You can mix and match key types
+ len() gives you the number of keys in a dictionary
**** In a boolean context
+ empty dictionary is false
+ all others are true
*** None
None is a special constant - not the same as False
+ Comparing to anything other than None will return False
+ has its own datatype NoneType
+ You can assign None to any variable but you can not create other NoneType objects. All variables with the value of None are equal to each other
+ In a boolean context None is false and not None is true

** Chapter 3 Comprehensions
*** Detour - Working with Files and directories
Python comes with os module that contains functions for working with the filesystem, environment and processes. Python tries to have a unified API across all supported operating systems so that programs can run with a minimum of platform specific code

**** Current working directory
- there is always a current working directory, in the REPL, when running a script etc.
-  Python os module has two functions os.getcwd() returns the working directory and os.chdir('/path/to/where/I/want') - note that on a windows machine the last command would take me to c:\path\to\where\I\want

**** Working with Filenames and Directory names
os.path contains functions for manipulating file and directory names
- os.path.join will construct a pathname from one or more partial pathnames
- python will work out if you need forward or backslashes...
- os.path.expanduser() will expand ~ into the current users home directory Even on windows!
-
* Other Sources
** [[[[https://www.youtube.com/watch?v=qbLc5a9jdXo]]][Rest API]]
Commonly APIs use JSON - key value pairs much like an object it JS(where it
came from) or a dictionary in python. REST is representational state
transfer - requests over the web that are responded to with JSON. Allows back
end and front end to communicate. API provides better security so that front
end JS is not directly accessing the database. The API allows for the same
API to be used by different front ends. Modular approach allows changes to
the back end to be made without causing problems for the front end as long as
the back end maintains the same endpoints. By making only certain endpoints
public you can allow the public to consume certain services without exposing
the entire system to the public.
+ Different methods of requesting data from the server
- GET is used to retrieve data
- POST is used to write data to the server
- DELETE to delete stuff
- PUT used to update data? overlaps with POST
accronym CRUD (create, )


* [[https://youtu.be/JeznW_7DlB0][Tech with Tim OOP for beginners ]]
Tutorial that gets into more advanced elements of Python
+
* Data structures and Algorithms in Python
** Chapter 1
+ an alias can be created by assigning a second identifier to an object. Because identifiers behave like pointers if a change is made through one identifier than it will be apparent when using the other alias. If one of the names is assigned to another value using an assignment statement it will break the alias and the identifier will point to the new object. So temp = 98.6, other = 98.6 temp = temp +1, temp now = 99.6 but other = 98.6
**** the bool class
+ methods that return information about an object without changing it state ar known as accessors. Methods that do change the state of an object are known as mutators or update methods
+ creating a new instance of a class is instatiation. This can be done by calling a constructor method. Many built in classes have support for a literal for for designating a new instance temp = 9.8 creates a float. 9.8 is a literal form. A function or method can return an instance of a class
+ Python supports both traditional function calls myfunc(my, param) as well methods called through dot notation
*** 1.2.3 Python's Built in Classes

|-----------+-------------------------------------+-----------|
| Class     | Description                         | Immutable |
|-----------+-------------------------------------+-----------|
| bool      | Boolean Value                       | Yes       |
| int       | integer                             | Yes       |
| float     | floating point                      | yes       |
| list      | ordered list                        | no        |
| tuple     | immutable ordered list              | Yes       |
| str       | list of characters                  | yes       |
| set       | unordered grouping of unique values | no        |
| frozenset | immutable form of set               | yes       |
| dict      | associative mapping                 | no        |

+ bool - usually created in literal form.
+ int and float

* Python for Everybody - I can at least get credit for doing this
+ Assignments and badges from webpage. Coursera course!
+ Is based on how to think like a computer scientist but with a focus on data analysis rather than more general programming. I can probably combine this with dive into Python to get a decent intro course. Will also need scripting stuff for the devops....
** Chapter 1
+ Computers are good at tasks that people are not - like crunching data, repeating simple steps identically etc. Computers are extremely literal, programming requires being precise to avoid syntax errors. Luckily things like LSP exist to warn me when there is a problem.
+ Hardware architecture: I know this stuff already
+ Python as a language: Designed to be easy to read, very popular.

** Chapter 2
+ constants - variables that don't change. 
+ You can't use reserved words.
+ listen to video lectures and do online exercises


** Chapter 3
+ Logical operators - and, or, not. Conditional execution: simplest is the if statement. Boolean expression after the if statement is called the condition. The if statement is ended with a colon (:) lines that are part of the statement are indented.
+ Nested conditions can get hard to read - using compound statements with logical operators like and or or...
+ Exceptions: unhandled exceptions will cause a script to halt...
+ conditional execution structure called try / except handles areas like user input that may need to deal with error causing or unexpected results.
+ the except block is only executed in case of an error

#+BEGIN_SRC python

inp = input('Enter Fahrenheit Temperature:')
try:
    fahr = float(inp)
    cel = (fahr - 32.0) * 5.0 / 9.0
    print(cel)
except:
    print('Please enter a number')
#+END_SRC

+ the interpreter jumps to the except block if an error is encountered while executing the try block. Called catching rather than handling the exception
+ Logical expressions are evaluated fri left to right. In expressions that use the and operator if the first statement evaluates to false the second statement is not checked. When evaluation of a compound statement is stopped before all component's are checked it is called short-circuiting the evaluation.
+ Short-circuiting can be used to create guardian patterns. By placing a statement that will evaluate to false for values that would cause issue (divide by 0) first in an and statement the evaluation that would cause an error is never done.
+ 3.9 Debugging: tracebacks provide information on the cause of the error including what the type of error and where it occurredi.
+ Notes from watching the lecture - I need to get better at paying attention to indentation. I still have issues when looking at python code blocks. Use 4 space indentation. I need to make sure that I have tabexpand set.
+ Multiway branching - elif checks the conditions in the order that they appear. If a true condition is reached the subsequent conditions will not be checked and python will exit the condition code block.


** Chapter 4 Functions
+ Python comes with a set of built in functions including max, min, len - all of which work on a set of values. The names of built in functions should be treated as keywords.
*** Conversion functions
+ int will try to turn a value into an integer or it will raise an error. If used on a float it will truncate the number and return the value that is before the decimal point.
*** Math functions
+ Python include a math module that can be imported (import math) the functions and variables in the module can be accessed through dot notation (math.log10(), math.pi)
*** Random Numbers
+ actual random numbers are hard to generate. random module produces pseudo-random numbers random.random() produces a pseudo-random number between >= 0.0 and < 1.0
+ random.randint(low high) produces an integer between low and high (inclusive)
+ random.choice selects an element from a sequence of values.
+ random also contains functions to generate values from common distributions
*** Adding function
+ function definitions start with def keyword
+ name can contain letters numbers and some punctuation marks. First character can not be a number.
+ First line is the header, followed by the body.Header ends with : the body is indented - convention is usually 4 spaces (Alphabet uses 2 space indentation)
+ Defining a function creates a variable of the same name of type function.
+ Functions need to be defined before they are called
*** Flow of execution
+ Execution always begins with the first statement of the progrsm and procedes from top to bottom. Function definitions create the function but statements inside the function are not executed until the function is called (that is why if a local var is defined with the same name as a global var inside a function, trying to call the variable before the local declaration does not go to the global definition but instead produces an error.)
*** Parameters and arguments
+ inside a function arguments are assigned to local values called parameters
  if in the function call an expression is used as an argument it is evaluated before the function is called and assigned to the parameter
+ void functions (that dont specify a return value) return the value of None of type NoneType
*** Notes from the videos
+ Advantages of functions - store and reuse
+ new keyword def.
+ return without a parameter ends the function (like break ends a loop)
+



** Chapter 5 - Iteration
*** While statement
+ the value of the variable used to determine if the loop is finished should be updated in the while block (or else the loop will never exit) The variable that is changed each time the loop runs is called the iteration variable. A infinite loop with a break statement that is executed when some condition is reached in the middle of the loop (user input for instance)
+ continue statement skips to the next iteration without finishing the body of the loop
*** For loops
+ used when there is a list of items to iterate over or other defined number of iterations to run.
+ called a definite loop instead of an indefinite loop like the while statement
*** Loop patterns
+ Counting and summing
  #+BEGIN_SRC python
    count = 0
    for itevar in [3, 41, 12, 9, 74, 15]:
        count = count + 1
    print('Count: ', count)
   #+END_SRC
   This prints out a count of the number of items in the list. Note that in a for loop the iteration variable does not need to be used in the loop body
*** Notes from video lectures
+ for loop is a definite loop - the number of iterations is known before the loop starts.
**** Solving problems with loops
+ for things in data - look for or do something to each item in data. Do something with the results
+ compare and update a variable for each item in data (largest_so_far)
+ like moving a window across the array and writing something down at each stop
+ updating a counter for each item in the data - wouldnt this be the same as taking the size of an array or something?
+ keeping a total by adding each value to a variable with both a count and a total you have the average
+ filtering in a loop. having a conditional that triggers if the value for an item in the data being iterated over meets some criteria. Also can use a boolean that is changed if some value is found/condition met (or use a function to return the triggered state)
+ None type. None is a constant, can be used to indicate that a variable has not had a value assigned to it yet.
+ is (or is not) operator can be used to see if a variable is set to None. Sort of like the == checks for type an value, stronger, use with booleans and None to avoid confusion

** Chapter 6 - Strings 
+ Individual characters from a string can be accesed using bracket notation. Index starts at 0...
+ len(myString) returns the length of the string as an integer. Because the index starts at 0 the last character is myString[len(myString-1)] or use negative indices to count backwards from the end.
+ Going through each character in a string is called traversal
  #+BEGIN_SRC python
   index =0
   while index < len(fruit):
     letter = fruit[index]
     print(letter)
     index = index + 1
   #+END_SRC
   This prints out each letter in turn on its own line.

+ empty string is represented by '' and is length 0
+ You can't use someString[someIndex] on the left of an assignment operator to change the character at that location
+ ?Can strings be changed? I assumed that you needed to create a new string and then it could be assigned to the name of the old string.... 'str' obect does not support item assignment... strings are immutable 
*** String methods
+ comparison operator can be used to put words in alphabetical order. NOTE: All uppercase letters come before the lowercase letters. To compare words without error it is usual to convert them into a common format - often all lowercase before performing the comparison. 
+ Strings are objects and therefore have methods that are built into the object and are available to each instance
+ Python function dir lists available methods for an object. Type function shows the type of an object
+ methods are called by appending the method name to the object using dot notation. This is called invoking the method 
+ The in operator is a boolean operator that takes two strings and return True if the first appear as a substring in the second.
+ Python dir function lists the methods available for an object
+ type function shows the type of an object
+ help gets simple documentation on a method.
+ python.org is a more complete source of documentation.
+ the find method finds the index of a substring in a string. Can also use a second argument to indicate where the search should start.
+ strip method removes white space characters such as space tab and newline.
+ myString.startswith('someString') returns True if myString starts with someString
+ line.lower().startswith('h') will return True if the string line starts with h or H
*** Parsing Strings
Finding and copying a portion of a string
+ to find the domain portion of an e-mail in a string - step 1 find the @ sign. Step 2 find the first space after the @ sign. Step 3 copy the string from 1 further than the @ to one before the space.
+ Documentation for the find method Finding and copying a portion of a string
  + to find the domain portion of an e-mail in a string - step 1 find the @ sign. Step 2 find the first space after the @ sign. Step 3 copy the string from 1 further than the @ to one before the space.+ Documentation for the find method https://docs.python.org/library/stdtypes.html#string-methods
*** Format operator
+ the format operator % lets you use variables in the construction of strings. When % is applied to integers it is the mod operator but when the first operand is a string the % is the format operator.
+ The first operand is the format string which contains format sequences that specify how the second operand is formatted. The output is a formatted string - the format sequence %d means that the second operand should be formatted as an integer (the d stands for decimal) '%d' % my_int produces a string of the integer in my int
+ To format a sentence you can include the format sequence in a string.
  #+BEGIN_SRC python
  my_int = 42
  print('I have spotted %d camels.' % camels)
  #+END_SRC
+ If there are multiple format sequences in a string the second argument needs to be a tuple. Each format sequence is matched with an element in order. The number and type of the elements in the tuple must match the format sequence. %g is use to format floats and %s is used to format strings
  #+BEGIN_SRC python
  print('In %d year I have spotted %g %s.' % (3, 0.1, 'camels'))
  #+END_SRC
+ more info https://docs.python.org/library/stdtypes.html#printf-style-string-formatting
*** Debugging
+ When designing a program it is important to think of all the things that could go wrong and what possible inputs the user will try to use to crash the program.
+ When using an if statement to check what the first character is it is important to deal with blank lines. if userInput[0] == 'something' will produce an error if userInput is empty. One way is to use useInput.startswith('something') which will return False if the string i empty.
+ Gaurdian patterns - if the first part of a statement with an and operator is False the second part is never evaluated. This can be used to prevent errors
  #+BEGIN_SRC python
  if len(line) > 0 and line[0] == '#':
  #+END_SRC
  will not produce errors from line[0] trying to evaluate an empty string because the python interpreter will stop evaluating the compound statement when len(line) > 0 evaluates to false
*** Notes from video lecture
Strings have indexes just like arrays lists, tuples. Indexes can be calculated values. If you try to index past the size of a string you get an error (some methods handle this better than others). Last element is len(someString) - 1.
+ Looping through strings - used to look for or count something. Can write the loop to count based on the result of the length method. Using a for loop is the preferred approach, unless you need the index(iteration variable) for something else.
  #+BEGIN_SRC python
  for letter in string:
      print(letter)
  #+END_SRC
  will print out the letters in string just like
  #+BEGIN_SRC python
  index = 0
  while index < len(string):
      letter = string[index]
      print(letter)
      index = index + 1
  #+END_SRC
+ you can do all the iteration stuff like looking for a value or counting the number of occurrences or find the largest or smallest value
+ the in operator - the iteration variable (letter) iterates through the sequence. The block of code is executed once for each value in the sequence. The iteration variable moves through all the values in the sequence.
+ the in expression is also a logical expression that returns True or False and can be used in an if statement.
  #+BEGIN_SRC python
  fruit = 'banana'
  'n' in fruit
  # will return True
  'm' in fruit
  # will return False
  #+END_SRC
**** String functions
Strings have a bunch of built in functions that I should probably study
Many of these functions return an altered string. Because strings are immutable the content of the strings is not changed
**** Video part 2 slicing strings
+ If you omit either of the end point from a string slice it will assume you
mean either the beginning or the end of the string. 
 
** Chapter 7 Files
*** Notes From video
+ Text files can be thought of as a sequence of lines. 
+ To open a file we use:  handle = open(filename, mode) - filename is a
string, mode will be r to read from the file or w to write to the file
+ If the file does not exist you get an error. 
+ newline character represented by \n this is considered one character (like
all of the escape codes. 
*** 7.1 Persistence
+  
