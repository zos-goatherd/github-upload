#+TITLE: Python notes

* Dive into python3
** Chapter 1
+ Notes: All functions return something if not specified in the function than return value will be none
  no explicit types...
+ Function arguments can be in any order as long as they are named. Once a named argument is used all further arguments must be named.
+ Docstrings: A triple quote starts (and stops) a multiline comment - such as a doc string, They may contain single and double quotes. A docstring if it exists must be the first thing defined in a function - it must start on the first line after the declaration. The docstring is also available at runtime as an attribute of the function.  Also used by IDE's for tooltips.
+ Import search path: search path is a list defined in sys.path. New directories can be added at runtime by adding the directory name to sys.path - sys.path.insert(0 new_path) inserts a new directory as the first item in the list (directories are searched in the order they appear until a .py file whith a name that matches the import statement is found)
+ Once a .py file is imported as a module any of its public functions, classes or attributes are available to other modules or interactively through the REPL
+ when calling a function use moduleName.Function
+ Python functions (like everything else in Python) are objects and have attributes that are available at runtime.
+ Objects in python do not need to have attributes or methods - not all objects are subclassable. Everything is an object in the sense that it can be assigned to a variable or passed as an argument to a function.
+ In Python functions are first class objects and can be passed  as argument to other functions. Modules and classes (or instances of a class) as well
+ Is this the same sort of flexibility that allow for meta-programming in LISP?
+ Indenting code: Instead of using punctuation marks to mark out blocks of code Python uses indentation... Whitespace use must be consistent...
+ Exceptions: Instead of using return codes to indicate errors. Python uses exceptions that once raised need to be handled. Unhandled exceptions will cause a programs execution to halt. Functions dont declare which exceptions may be raised. Not all exceptions are errors - some are fairly easy to anticipate (like a file not opening because it does not exist yet)
+ If a line of code is likely to raise an exception use a try-except block. Use raise statement to generate exceptions.
+ raise statement myExceptionName('optional human readable debugging info') - this creates an instance of the ValueError class and passing the string to its initialization method.
+ Exceptions that are not handled in the function that raises it are passed to the calling function until handled or the program crashes and Python prints a traceback error.
+ One common built in exception is the ImportError - handling it provide a way to have the features of a program gracefully degrade if certain libraries will only be available in certain circumstances.
  #+BEGIN_SRC python
    try:
        import chardet
    except ImportError:
        chardet = None

    if chardet:
        # code based on having chardet librqary
    else:
        # the rest of the program
  #+END_SRC
  This exception can also be used when there are multiple modules that implement an API to allow one to be used only if the other one is not available without needing to have further code to determine which version was imported.
+ Everything in Python is case sensitive.
+ Modules have several built in attributes. if a module is imported __name__ will be the modules filename (without path info or extension) if the module is run as a standalone __name__ will default to __main__ This can be used for unit testing

** Chapter 2 - datatypes
1. Boolean
2. Numbers: can be integers fractions, floats, or complex
3. Strings: sequence of unicode characters
4. Bytes and byte arrays: binary files etc
5. Lists: ordered sequence of values
6. Tuples: orderd immutable sequence of values
7. Set: unordered collection of values
8. Dictionaries: unordered collection of key-value pairs.
Plus lots of other stuff since everything is an object in Python.
+ Boolean 0 = false every other number evaluates to true
*** Lists : Workhorse of basic Python. Can expand dynamically
   - a_list = ['a', 'b', 'c', 'foo']
   - a_list[0]= 'a'
   - lists can be sliced a_list[1:2] returns ['b'] the first number is the number to start with and the second is the number to stop before.
     - If an indice is the first or last item it can be left out: a_list[:] returns a copy of the entire list. The copy is a new list and therefore is not the same as the a_list variable despite having the same values
     - a_list[:-1] returns everything but the last element a_list[1:] returns every element excluding the first
   - Adding items to a list
     - the + operator concatenates two lists to create a new list that is immediately assigned to the existing list so
       #+BEGIN_SRC python
       my_list = ['a']
       my_list = my_list + ['b', 'c', 4.0, 5]
       #+END_SRC
       Produces my_list['a', 'b', 'c', 4.0, 5]
     - my_list.append(True) would add true to the end of the list. The append method takes a single argument of any data type and adds it to the end of the list. If you append with a list as the aargument the entire list will be added as a single item (creating amultidimensional list)
     - my_list.extend(['moreValues', 'False']) will add two more values to the list. Extend takes a list as an argument and adds each item to the list that called it.
     - my_list.insert(3, 'a') would insert 'a' into the list at the 4th position because list items do not need to be unique my_list would be ['a', 'b', 'c', 'a', 4.0, 5, True, 'moreValues', False]
     - Lists are an implemented as classes so append,extend, and insert, are methods that operate on a list
   - Searching for values in a list
     - my_list.count(True) would return the number of times the value True appear in my_list. The index method returns the index of the first occurrence. The index method can also take a second argument that indicates the index to start searching and a third argument of the index to stop searching. This can allow you to find the index of occurrences of a value other than the first one
     - a in my_list would return True
     - if you call index and the value does not occur in the list you will get an exception raised
   - Removing items from a list
     - del my_list[1] removes the second item from a list. The third item will then become the second (or if there is no third the list will be of size 1)
     - my_list.remove('c') will remove the first occurrence of the item 'c' from my_list or raise an exception if the value does not exist.
     - my_list.pop() will remove the last item from my_list and return the value that it removed
     - can also be used with the index of the item to remove
     - pop will raise an exception if called on an empty list
   - Lists in a Boolean context
     - empty lists evaluate to false
     - a list with at least one item is true - even if the value is False.
*** Tuples
A tuple is an immutable list, so great for functional programming. my_tuple = ("I", "love", "clojure", "True", 42, 23, 93)
+ Tuple are ordered and have 0 based indices
+ a negative index indicates counting from the end of the tuple
+ slicing a tuple produces a new tuple - my_tuple[1:3] returns ("love", "clojure")
+ tuples have no methods that allow their values to change. you can use index or search using "I" in my_tuple
+ tuples are faster than lists. They are read only so are safer than lists.
+ Some tuples can be used as dictionary keys (tuples that contain immutable values like strings, numbers, or other tuples) Since dictionary keys must be immutable lists dont work
+ The tuple() function takes a list and returns a tuple. The list() function takes a tuple and returns a list
+ To create a tuple of one item you need to put a comma after the item or else python will ignore the parentheses so type((False)) returns bool while type((False,)) returns tuple
+ Tuples can be used to assign multiple values at once. t = (1, '1', 2, 3.0)
  (var1, var2, var3, var4) = t results in var1 being equal to 1 var2 being equal to '1' and so on
+ you can use tuples to have a function return multiple values and either have the caller keep the values in a tuple or break them out into individual variables, or make a list for that matter

*** Sets
A set is an unordered collection of unique values of any immutable datatype. With two sets you can do set operations like union, intersection, and set difference.
+ Creating a set my_set{1, 2, 'a', True}
+ my_other_set = set(my_list) creates a set from my_list
+ you can create an empty set a_set = set()
+ the empty set is represented by set() {} is a dictionary for some reason... so not_a_set = {} creates am empty dictionary
+ my_set.add(3) will add 3 to my_set. my_set.add(1) will do nothing as a set is made up of unique values so adding an existing value does not create multiple occurrences
+ my_set.update() takes an argument of a set and adds each member to the calling set.
+ the update method can actually be called with multiple sets and will combine all the values with the ones from the original set
+ update can be used with lists as well
+ removing items from a set - discard method takes a single value and removes it from a set If the value is not part of the set it is a no-op (does not raise an exception)
+ remove also takes a value out of a set but raises an error if the value was not part of the set
+ pop method will remove a random value from a set and returns it. Since sets are unordered there is no way of predicting which value will be removed. If pop is called on an empty set it raises an exception
+ clear method removes all values so you end up with an empty set. clear is equivalent to taking a_set_with_some_values = set() which overwrites the previous values with an empty set
+ someValue in a_set return true if the value is in the set
+ a_set.union(b_set) returns a set with the values from both sets.(either set)
+ a_set.intersection(b_set) returns a set of the common values that are in both sets
+ a_set.difference(b_set) returns a  new set with elements that are members of a that are not in b
+ a_set.symmetric_difference(b_set) returns a new set that contain elements that were in exactly one of the sets.
+ a_set.issubset(b_set) returns true is all elements in a are also in b
+ b_set.issuperset(a_set) reverse of above
+ boolean value of an empty set is False, other sets (ones with at least one element) are True. Value of the elements does not matter.... so a set that contains the string False and nothing else will evaluate to true.
*** Dictionaries
- Unordered
- key value pairs.
- when a key is added it must also have a value
- optimized for using the key to find the value, but not good at finding the key when you know the value.
- Acts like a hash in Perl 5
**** Creating a dictionary
+ my_dict = {'server': 'db.diveintopython3.org', 'database': 'mysql'}
+ you can't look up keys from the value.
+ no predefined size limit you can add new key-value pairs and you can modify the value of an existing ey
+ you can't have duplicate keys
+ dictionaries are unordered
+ keys are case sensitive so User != user
+ Dictionaries values can be any datatype including other dictionaries.
+ dictionary keys are more restrictied they can be strings integers and a few other types. You can mix and match key types
+ len() gives you the number of keys in a dictionary
**** In a boolean context
+ empty dictionary is false
+ all others are true
*** None
None is a special constant - not the same as False
+ Comparing to anything other than None will return False
+ has its own datatype NoneType
+ You can assign None to any variable but you can not create other NoneType objects. All variables with the value of None are equal to each other
+ In a boolean context None is false and not None is true

** Chapter 3 Comprehensions
*** Detour - Working with Files and directories
Python comes with os module that contains functions for working with the filesystem, environment and processes. Python tries to have a unified API across all supported operating systems so that programs can


**** Working with Filenames and Directory names
os.path contains functions for manipulating file and directory names
- os.path.join will construct a pathname from one or more partial pathnames
- python will work out if you need forward or backslashes...
- os.path.expanduser() will expand ~ into the current users home directory Even on windows! It will not put a trailing slash on the path but the join() function will do that automatically when joining the filename to the path
- os.path.split(pathname) will take a path and return a tuple with the path and the filename. You can use multivariable assignment to assign the two parts of the filename to variables contained in a tuple.
- you can also use is.splitext that takes a filename and returns a tuple of the name and the extension.

**** listing directories
- the Python standard library also has a glob module to make it easier to get the filenames you need from a directory. use import glob to start using globs.

**** Getting File Metadata
Stuff like creation date, last modified, size.... Python uses the same API for every OS. You can access metadata without opening the file using myVar = os.stat('myFilename')  The os.stat() function returns an object with the different metadata.
+ To access the modification time use myVar.st_mime to get the time since Epoch. To convert this into a more convenient format use import time from the Python standard library. The time module contain functions to convert time formats as well as format time stamps into strings and for dealing with timezones. To convert from seconds since Epoch use time.localtime(myVar.st_mime) This will return a structure that tells you year month day hour minute second....
+ myVar
** Chapter 4 Strings

*** Other Common String Methods 4.5
Besides formatting there are a number of other methods for strings.
+ You can use triple quotation marks for multi-line strings
+ the splitlines() method takes a multi-line string and returns a list of strings. The carriage return at the end of each line is not included.
+ lower() method converts the entire string to lowercase
+ upper() yep
+ count() takes a string and returns the number of occurrences in the calling string.
+ example:
  #+BEGIN_SRC python
query = 'user=pilgrim&database=master&password=PapayaWhip'
a_list = query.

#+END_SRC
* Other Sources
** [[[[https://www.youtube.com/watch?v=qbLc5a9jdXo]]][Rest API]]
Commonly APIs use JSON - key value pairs much like an object it JS(where it
came from) or a dictionary in python. REST is representational state
transfer - requests over the web that are responded to with JSON. Allows back
end and front end to communicate. API provides better security so that front
end JS is not directly accessing the database. The API allows for the same
API to be used by different front ends. Modular approach allows changes to
the back end to be made without causing problems for the front end as long as
the back end maintains the same endpoints. By making only certain endpoints
public you can allow the public to consume certain services without exposing
the entire system to the public.
+ Different methods of requesting data from the server
- GET is used to retrieve data
- POST is used to write data to the server
- DELETE to delete stuff
- PUT used to update data? overlaps with POST
accronym CRUD (create, )

* Corey Schafer
** Unit testing
+
** Python oop
+
* [[https://youtu.be/JeznW_7DlB0][Tech with Tim OOP for beginners ]]
Tutorial that gets into more advanced elements of Python
+
* Data structures and Algorithms in Python
** Chapter 1
+ an alias can be created by assigning a second identifier to an object. Because identifiers behave like pointers if a change is made through one identifier than it will be apparent when using the other alias. If one of the names is assigned to another value using an assignment statement it will break the alias and the identifier will point to the new object. So temp = 98.6, other = 98.6 temp = temp +1, temp now = 99.6 but other = 98.6
**** the bool class
+ methods that return information about an object without changing it state ar known as accessors. Methods that do change the state of an object are known as mutators or update methods
+ creating a new instance of a class is instatiation. This can be done by calling a constructor method. Many built in classes have support for a literal for for designating a new instance temp = 9.8 creates a float. 9.8 is a literal form. A function or method can return an instance of a class
+ Python supports both traditional function calls myfunc(my, param) as well methods called through dot notation
*** 1.2.3 Python's Built in Classes

|-----------+-------------------------------------+-----------|
| Class     | Description                         | Immutable |
|-----------+-------------------------------------+-----------|
| bool      | Boolean Value                       | Yes       |
| int       | integer                             | Yes       |
| float     | floating point                      | yes       |
| list      | ordered list                        | no        |
| tuple     | immutable ordered list              | Yes       |
| str       | list of characters                  | yes       |
| set       | unordered grouping of unique values | no        |
| frozenset | immutable form of set               | yes       |
| dict      | associative mapping                 | no        |

+ bool - usually created in literal form.
+ int and float

* Python for Everybody - I can at least get credit for doing this
+ Assignments and badges from webpage. Coursera course!
+ Is based on how to think like a computer scientist but with a focus on data analysis rather than more general programming. I can probably combine this with dive into Python to get a decent intro course. Will also need scripting stuff for the devops....
** Chapter 1
+ Computers are good at tasks that people are not - like crunching data, repeating simple steps identically etc. Computers are extremely literal, programming requires being precise to avoid syntax errors. Luckily things like LSP exist to warn me when there is a problem.
+ Hardware architecture: I know this stuff already
+ Python as a language: Designed to be easy to read, very popular.

** Chapter 2
+ constants - variables that don't change. 
+ You can't use reserved words.
+ listen to video lectures and do online exercises

** Chapter 3
+ Logical operators - and, or, not. Conditional execution: simplest is the if statement. Boolean expression after the if statement is called the condition. The if statement is ended with a colon (:) lines that are part of the statement are indented.
+ Nested conditions can get hard to read - using compound statements with logical operators like and or or...
+ Exceptions: unhandled exceptions will cause a script to halt...
+ conditional execution structure called try / except handles areas like user input that may need to deal with error causing or unexpected results.
+ the except block is only executed in case of an error

#+BEGIN_SRC python

inp = input('Enter Fahrenheit Temperature:')
try:
    fahr = float(inp)
    cel = (fahr - 32.0) * 5.0 / 9.0
    print(cel)
except:
    print('Please enter a number')
#+END_SRC

+ the interpreter jumps to the except block if an error is encountered while executing the try block. Called catching rather than handling the exception
+ Logical expressions are evaluated fri left to right. In expressions that use the and operator if the first statement evaluates to false the second statement is not checked. When evaluation of a compound statement is stopped before all component's are checked it is called short-circuiting the evaluation.
+ Short-circuiting can be used to create guardian patterns. By placing a statement that will evaluate to false for values that would cause issue (divide by 0) first in an and statement the evaluation that would cause an error is never done.
+ 3.9 Debugging: tracebacks provide information on the cause of the error including what the type of error and where it occurredi.
+ Notes from watching the lecture - I need to get better at paying attention to indentation. I still have issues when looking at python code blocks. Use 4 space indentation. I need to make sure that I have tabexpand set.
+ Multiway branching - elif checks the conditions in the order that they appear. If a true condition is reached the subsequent conditions will not be checked and python will exit the condition code block.

** Chapter 4 Functions
+ Python comes with a set of built in functions including max, min, len - all of which work on a set of values. The names of built in functions should be treated as keywords.
*** Conversion functions
+ int will try to turn a value into an integer or it will raise an error. If used on a float it will truncate the number and return the value that is before the decimal point.
*** Math functions
+ Python include a math module that can be imported (import math) the functions and variables in the module can be accessed through dot notation (math.log10(), math.pi)
*** Random Numbers
+ actual random numbers are hard to generate. random module produces pseudo-random numbers random.random() produces a pseudo-random number between >= 0.0 and < 1.0
+ random.randint(low high) produces an integer between low and high (inclusive)
+ random.choice selects an element from a sequence of values.
+ random also contains functions to generate values from common distributions
*** Adding function
+ function definitions start with def keyword
+ name can contain letters numbers and some punctuation marks. First character can not be a number.
+ First line is the header, followed by the body.Header ends with : the body is indented - convention is usually 4 spaces (Alphabet uses 2 space indentation)
+ Defining a function creates a variable of the same name of type function.
+ Functions need to be defined before they are called
*** Flow of execution
+ Execution always begins with the first statement of the progrsm and procedes from top to bottom. Function definitions create the function but statements inside the function are not executed until the function is called (that is why if a local var is defined with the same name as a global var inside a function, trying to call the variable before the local declaration does not go to the global definition but instead produces an error.)
*** Parameters and arguments
+ inside a function arguments are assigned to local values called parameters
  if in the function call an expression is used as an argument it is evaluated before the function is called and assigned to the parameter
+ void functions (that dont specify a return value) return the value of None of type NoneType
*** Notes from the videos
+ Advantages of functions - store and reuse
+ new keyword def.
+ return without a parameter ends the function (like break ends a loop)
+


** Chapter 5 - Iteration
*** While statement
+ the value of the variable used to determine if the loop is finished should be updated in the while block (or else the loop will never exit) The variable that is changed each time the loop runs is called the iteration variable. A infinite loop with a break statement that is executed when some condition is reached in the middle of the loop (user input for instance)
+ continue statement skips to the next iteration without finishing the body of the loop
*** For loops
+ used when there is a list of items to iterate over or other defined number of iterations to run.
+ called a definite loop instead of an indefinite loop like the while statement
*** Loop patterns
+ Counting and summing
  #+BEGIN_SRC python
    count = 0
    for itevar in [3, 41, 12, 9, 74, 15]:
        count = count + 1
    print('Count: ', count)
   #+END_SRC
   This prints out a count of the number of items in the list. Note that in a for loop the iteration variable does not need to be used in the loop body
*** Notes from video lectures
+ for loop is a definite loop - the number of iterations is known before the loop starts.
**** Solving problems with loops
+ for things in data - look for or do something to each item in data. Do something with the results
+ compare and update a variable for each item in data (largest_so_far)
+ like moving a window across the array and writing something down at each stop
+ updating a counter for each item in the data - wouldnt this be the same as taking the size of an array or something?
+ keeping a total by adding each value to a variable with both a count and a total you have the average
+ filtering in a loop. having a conditional that triggers if the value for an item in the data being iterated over meets some criteria. Also can use a boolean that is changed if some value is found/condition met (or use a function to return the triggered state)
+ None type. None is a constant, can be used to indicate that a variable has not had a value assigned to it yet.
+ is (or is not) operator can be used to see if a variable is set to None. Sort of like the == checks for type an value, stronger, use with booleans and None to avoid confusion

** Chapter 6 - Strings 
+ Individual characters from a string can be accesed using bracket notation. Index starts at 0...
+ len(myString) returns the length of the string as an integer. Because the index starts at 0 the last character is myString[len(myString-1)] or use negative indices to count backwards from the end.
+ Going through each character in a string is called traversal
  #+BEGIN_SRC python
   index =0
   while index < len(fruit):
     letter = fruit[index]
     print(letter)
     index = index + 1
   #+END_SRC
   This prints out each letter in turn on its own line.

+ empty string is represented by '' and is length 0
+ You can't use someString[someIndex] on the left of an assignment operator to change the character at that location
+ ?Can strings be changed? I assumed that you needed to create a new string and then it could be assigned to the name of the old string.... 'str' obect does not support item assignment... strings are immutable 
*** String methods
+ comparison operator can be used to put words in alphabetical order. NOTE: All uppercase letters come before the lowercase letters. To compare words without error it is usual to convert them into a common format - often all lowercase before performing the comparison. 
+ Strings are objects and therefore have methods that are built into the object and are available to each instance
+ Python function dir lists available methods for an object. Type function shows the type of an object
+ methods are called by appending the method name to the object using dot notation. This is called invoking the method 
+ The in operator is a boolean operator that takes two strings and return True if the first appear as a substring in the second.
+ Python dir function lists the methods available for an object
+ type function shows the type of an object
+ help gets simple documentation on a method.
+ python.org is a more complete source of documentation.
+ the find method finds the index of a substring in a string. Can also use a second argument to indicate where the search should start.
+ strip method removes white space characters such as space tab and newline.
+ myString.startswith('someString') returns True if myString starts with someString
+ line.lower().startswith('h') will return True if the string line starts with h or H
*** Parsing Strings
Finding and copying a portion of a string
+ to find the domain portion of an e-mail in a string - step 1 find the @ sign. Step 2 find the first space after the @ sign. Step 3 copy the string from 1 further than the @ to one before the space.
+ Documentation for the find method Finding and copying a portion of a string
  + to find the domain portion of an e-mail in a string - step 1 find the @ sign. Step 2 find the first space after the @ sign. Step 3 copy the string from 1 further than the @ to one before the space.+ Documentation for the find method https://docs.python.org/library/stdtypes.html#string-methods
*** Format operator
+ the format operator % lets you use variables in the construction of strings. When % is applied to integers it is the mod operator but when the first operand is a string the % is the format operator.
+ The first operand is the format string which contains format sequences that specify how the second operand is formatted. The output is a formatted string - the format sequence %d means that the second operand should be formatted as an integer (the d stands for decimal) '%d' % my_int produces a string of the integer in my int
+ To format a sentence you can include the format sequence in a string.
  #+BEGIN_SRC python
  my_int = 42
  print('I have spotted %d camels.' % camels)
  #+END_SRC
+ If there are multiple format sequences in a string the second argument needs to be a tuple. Each format sequence is matched with an element in order. The number and type of the elements in the tuple must match the format sequence. %g is use to format floats and %s is used to format strings
  #+BEGIN_SRC python
  print('In %d year I have spotted %g %s.' % (3, 0.1, 'camels'))
  #+END_SRC
+ more info https://docs.python.org/library/stdtypes.html#printf-style-string-formatting
*** Debugging
+ When designing a program it is important to think of all the things that could go wrong and what possible inputs the user will try to use to crash the program.
+ When using an if statement to check what the first character is it is important to deal with blank lines. if userInput[0] == 'something' will produce an error if userInput is empty. One way is to use useInput.startswith('something') which will return False if the string i empty.
+ Gaurdian patterns - if the first part of a statement with an and operator is False the second part is never evaluated. This can be used to prevent errors
  #+BEGIN_SRC python
  if len(line) > 0 and line[0] == '#':
  #+END_SRC
  will not produce errors from line[0] trying to evaluate an empty string because the python interpreter will stop evaluating the compound statement when len(line) > 0 evaluates to false
*** Notes from video lecture
Strings have indexes just like arrays lists, tuples. Indexes can be calculated values. If you try to index past the size of a string you get an error (some methods handle this better than others). Last element is len(someString) - 1.
+ Looping through strings - used to look for or count something. Can write the loop to count based on the result of the length method. Using a for loop is the preferred approach, unless you need the index(iteration variable) for something else.
  #+BEGIN_SRC python
  for letter in string:
      print(letter)
  #+END_SRC
  will print out the letters in string just like
  #+BEGIN_SRC python
  index = 0
  while index < len(string):
      letter = string[index]
      print(letter)
      index = index + 1
  #+END_SRC
+ you can do all the iteration stuff like looking for a value or counting the number of occurrences or find the largest or smallest value
+ the in operator - the iteration variable (letter) iterates through the sequence. The block of code is executed once for each value in the sequence. The iteration variable moves through all the values in the sequence.
+ the in expression is also a logical expression that returns True or False and can be used in an if statement.
  #+BEGIN_SRC python
  fruit = 'banana'
  'n' in fruit
  # will return True
  'm' in fruit
  # will return False
  #+END_SRC
**** String functions
Strings have a bunch of built in functions that I should probably study
Many of these functions return an altered string. Because strings are immutable the content of the strings is not changed
**** Video part 2 slicing strings
+ If you omit either of the end point from a string slice it will assume you
mean either the beginning or the end of the string. 
 
** Chapter 7 Files
*** Notes From video
+ Text files can be thought of as a sequence of lines. 
+ To open a file we use:  handle = open(filename, mode) - filename is a
string, mode will be r to read from the file or w to write to the file
+ If the file does not exist you get an error. 
+ newline character represented by \n this is considered one character (like
all of the escape codes.
+ It is also possible to read the content of a file one character at a time but this is a less common approach than reading the file line by line.
+ When reading from a file the line will include whitespace and the newline character
+ To itterate through a file by line use a for loop.
  afile = open('myfile.txt')
  count = o
  for somevar in afile:
      count = count + 1
  print('the line count is:' count)
+ It is possible, though not necessarily a good idea, to read an entire file into a string - newline characters and all.
  fhand = open('smallfile.txt')
  bigstring = fhand.read()
+ Searching through a file. In this case we are searching through an mbox file for all the lines that begin with From: (indicating the beginning of a new e-mail) ?how efficient is this?
  fhand = open('mbox-short.txt')
  for line in fhand:
      if line.startswith('From:') :
        print(line)
+ this will print out blank lines between each line as the print statement will append a newline to the line from the file that already ends with a newline
+ As these extra newlines and extra whitespace is a common problem we can use strip() and rstrip() that removes whitespace from the end of the string.
+ A slightly different way to structure the same thing
  #+BEGIN_SRC python
#!/ur/bin python3

fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if not line.startswith('From:') :
        continue
    print(line)

#+END_SRC
This way of writing it works if you want to do one or two things or simply skip some lines and then will have a big block of code acting on the lines that match your criteria...
+ Using in to select lines - We can look for a substring anywhere in a line using in. This example will print out all of the lines that contain a gmail address.
   #+BEGIN_SRC python
#!/ur/bin python3

fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if not '@gmail.com' in line :
        continue
    print(line)

#+END_SRC
+ the open() function takes a string as a parameter. You can get the string to use as the target filename from input or another file. As this will cause an error if the file does not exist in the working directory or the permissions on the file do not allow for the operation we are trying it is best to use some form of gatekeeping to prevent the program from ending with a traceback.

+ One simple way is to use a try and except block.

+ quit() ends a program without an error code

+ This basic pattern of opening a file and reading lines, removing whitespace, will be in almost every program.
*** 7.1 Persistence
+ When we open a file with myfilevar = open('afilename') open return a file handle object that allows us to perform file operations
+ if the file does not exist the operation will fail with a traceback
+ A text file can be considered a series of lines with the end of each line indicated by a newline character (\n in python) \n
+ to load an entire file into memory using the fhandle.read() function. Actually the read function can be used to return a specified number of bytes, the default of - return the whole file. Also it apparently can't be run on the same file handle twice.
+ using the find method to find lines
  #+BEGIN_SRC python
#!/ur/bin python3

fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if line.find('@gmail.com') == -1: continue
    print(line)

#+END_SRC

*** Writing files
+ fout = open('filename.txt', 'w')
+ if the file already exists opening it with the w option will overwrite the file....
+ might be a good idea to put checks in before opening a file this way to make sure that the file does not already exist.
+ fout.write(astring) will write astring to the file opened with fout and will return the number of characters written.
+ You can cal write again and it will append to the end of the text already writen (it is opening the file in write mode that deletes the previous file)
+ We need to make sure to manage the end of line and insert newline characters where appropriate. The write method does not automatically end the string it is writing to the file with a newline ?DOES IT INSERT A SPACE?
+ To make sure that all changes are written to disk we need to explicitly close the file with fout.close(). It is probably a good idea to do the same with files opened for reading, though since Python will do so when the program ends it is sometimes ommited.
+ If there is an issue with whitespace we can use the repr(badstring) function to see what is going on. It will print out a string with things like tabs and newline represented by escape sequences so we can see what is going on with the non printing characters.
+ Some OSs use characters other than \n for newline. I am fairly sure M$ use \r....
+ May need to convert or have some sort of a function to clean up the format if I am moving between OSs

** Chapter 8 - Lists
*** Notes from Video Part 1
+ Data structures are an important part of making an algorithm work. A
datastructure is  a collection of values. Different datastructures provide
different ways that the values are related and different built in ways to
perform operations on the values.
+ Lists can contain values of different types.
+ Lists can contain other lists.
+ for loops (definite loops) are used with lists
+ To access the elements of a list we use the index of the value starting
from 0
+ lists are mutable - unlike strings and tuples you can change the value
contained at a particular index. This can make lists more flexible but also
slower than some other data types
+ list.len() will return the number of items contained in a list
+ the range(x) returns a list starting from 0 with x number of items. This is 
often used in conjunction with len() to construct loops. For instance if you
have a list of names you want to send greetings to -
#+BEGIN_SRC python

for i in range(len(friends)) :
    friend = friends[i]
	greet(friend)
#+END_SRC
+ this use of range and length lets you keep track of the index as you
iterate through the loop and use the value for whatever you need. An example
is in the script to retry a call to a system resource that waits between
calls for a time dependent on how many times it has already tried. 
*** Notes from video part 2
+ Concatinating lists using + . Using the plus operator we can create a new
list that consists of the values of a list appended to the values of a second
list. listc = lista + listb
+ Slicing: list[x:y] x is the first element to include, y is the first
element to exclude. If you omit either number it will use either start from
the first element or include the last element.
+ list methods: there are a whole bunch of list related methods. It is
probably worth spending time reading up on the documentation as none of the
courses spend enough time on this
  - append: mylist.append(x) will add the value of x to the end of the list
  - creating an empty list: stuff = list() , this calls on the constructor
  class, it is also possible to use [  ]
  -  Python provides two operators that let you check if items are in a list.
  The in operator returns true if the value before the in is an element of
  the list so 9 in numbers would return true if the number 9 was an element
  of the list numbers. Also has a not in operator that returns true if the
  value before the not in is not in the list
  - Lists are in order and can be sorted with the sort method. It will try to
  arrange the items in the list in some sort of order. Lists are mutable so
  this will change the order of the items in place
  - There are various built in functions for lists like len, max, min, and
  sum These can be combined in various ways to do many of the tasks that I
  would usually need to write a function to do in another language. Some of
  these are not built into lists but rather take lists as an argument (so
  function notation rather than dot notation like the methods for the string
  class)
  - In some cases using a list rather than a loop to average a bunch of
  numbers is faster, but it takes more memory and may not scale well.
*** Notes from Video Part 3
+ Strings and lists. Often used in conjunction. Use similar notation.
+ The split function (myString.split()) and returns a list of strings. (Can also be used with a delimiter to work with CSV files. Defaults to whitespace to split if you do not specify a delimiter
+ Once you have split a string into a list you can easily traverse each word with a loop. Can also be one with the find method and using : to slice but that is harder for most people
+ when splitting by a character other than empty spaces the split function is not as clever - if there are 3 semicolons in a row it will create 3 empty items in the list while 3 blank spaces would be treated as a single space.
+ when extracting data from a text file you may need to use multiple splits one after another.
*** Lists Files and Guardian Patterns
+ when you encounter a bug it can be difficult to tell exactly what was going on that caused the problem. By inserting a print statement right before the line where the error occurred to indicate the values of key variables it can be easier to see what caused the issue
+ A guardian pattern keeps code that might cause issues from being executed. For instance if you are reading through a file checking each line for a word making sure that blank lines that trying to check the content of would cause an index out of bounds error (because a blank line has no words to check).
+ Guardian patterns can be used in a compound statement
  if len(wds) < 3 or wds[0] != 'From' :
      continue
  the order is important as the guardian pattern needs to short circuit the part of the evaluation that could cause an error.

*** A list is a sequence -
+ Several ways to create new lists - simplest is to enclose an element(s) in square brackets.
+ elements of a list do not need to be of the same type.
+ objects like lists can be elements of a list - this is how to create a multidimensional/nested list
+ to create an empty list []
+ a list can be assigned to a variable even = [0,2,4,6,8]
+ lists are mutable, you can access a list element by its index (position starting from 0)
+ integer expressions can be used as indecencies
+ attempting to access an element that does not exist is an IndexError
+ negative values count back from the end of the list
+ the in operator works on lists

*** Traversing a list

+ Most commonly done with a for loop for somevar in mylist: if you only need to read the elements of the list.
+ If you intend to do things with the elements you will need to use:

  for i in range(len(mylist)):
      mylist[i] = somethingelse

+ the range function returns a list from 0 to n-1 where in this case we are using len(mylist) as n

+ a for loop over an empty list never executes the code in the body

+ a nested list counts as a single element no matter how many elements it has (it is a single object)
*** List operations
+ The + operator concatenates lists
+ The * operator repeats a list the given number of times
+ The slice operator works on lists like it does on strings
*** List Methods
+ append adds a new element to the end of the list
+ extend takes a list as an argument and appends all of the elements
+ sort arranges the elements of a list from low to high *I need to look up how this handles different datatypes*
+ Most list methods are void - because lists are mutable they modify the list n place and return None. So t = t.sort() will give you t = [None]
*** Deleting elements
+ if you know the index of the item you can use pop. Pop modifies the list and returns the list element being removed. If used with no argument it will remove the last element.
+ del removes an item and does not return anything del mylist[someindex]
+ If you know the element you want to remove but not the index you can use myList.remove(element) the remove method returns None
+ the del method works with slicing so del myList[2:4] would remove the 3rd and 4th element of myList
*** Lists and Functions 8.8
built in functions that can be used on lists:
+ len(myList) returns the number of elements
+ max(myList) returns the largest element (look into how this function handles mixed types)
+ min(myList) returns the smallest element
+ sum(myList) returns the sum of the elements (look into how this handles non-numeric and mixed types) *answer* only works on numeric types. The other functions will work on other types that can be compared.
+ sum and len can be combined to get the average of a list. Using this method to calculate the average of a list of numbers should be more efficient than running the calculations inside a loop.
*** Lists and Strings 8.9
In Python a list of characters is not a string (dive into Python3 section on character encoding covers this in some detail) [[*Chapter 4 Strings]]
+ To convert from a string to a list of characters myList = list(myString) because list is the name of a built in function it should not be used as a variable; also l (lower case L) looks like a 1 (one) it is not a good idea to use them in situations where they might be confused
+ to break a string into words use the split method. This allows you to use the index of the list of individual words to access a perticular word. myString.split(delimiter) will split based on the character passed to the method as delimiter
+ join takes a list of strings and concatenates the elements. Join is a string method so it is invoked on the delimiter with a list of strings passed to it as an argument: delimiter = ' '; delimiter.join(myListofStrings) You can pass an empty string "" to join the string with no seperating character
*** Parsing Lines 8.10
Often when reading a line from a file or other source of data we will want to extract some element from the line. Usually we want to split the string so we can iterate over the elements of the string.  \
#+BEGIN_SRC python
fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if not line.tartswith('From '):continue
    words = line.split()
    print(words[2])

#+END_SRC

*** Objects and Value 8.11
If two variables have the same value we can use the is operator: a is b, this will return True if the variables both point to the same object and False if they just happen to have the same value. If you assign to variables the same string they will refer to the same object (strings are immutable, so while you can change one variable to point to some other value it is not possible to modify the string the variable points to) if you assign to variables to lists with the same set of values Python will create 2 lists that are equivalent but not identical.
*** Aliasing 8.12
The association between a variable and an object is a reference. If you want two variables to refer to the same list you can use a = [1, 2, 3, 4] and b = a. In this case because the list has more than one reference we say that the object is aliased. In this case because both a and b refer to the same object any changes to a will also change b. /Aliasing mutable object is an error prone way of writing code/ With string and other immutable objects (like tuples) aliasing is not a problem.
*** List Arguments 8.13
When a list is passed to a function the function gets a reference to the list and can make changes to the list (scope issue) Both the parameter in the function and the variable in the calling block will point to the same object. A variable used in the function - even if it has the same name as the parameter - will not be the same though. So if you have a function
#+BEGIN_SRC python
def bad_delete(t):
    t = t[1:]
#+END_SRC
will not change the value of t or the list it refers to outside of bad_delete as the slice operator return a new list that the new variable t points to. Using t.pop(0) should alter the list t refers to outside of the function. A better option than that would be to write a function that returns a new list.
Because of this it is important to be aware of how operators and methods deal with lists. Some of them return a new list while others make changes to the list. As an example the append method modifies a list(and returns None) but the + operator creates a new list. *See the notes I made on list methods in the dive into python3 section*
*** Debugging 8.14
Mutable objects can create strange behaviors when used without understanding how they might change at runtime.  \
**** Common Pitfalls
1. Most list methods modify the argument and return None. This behavior is opposite of the way similar methods work on strings and tuples. So if you try something like myString = myString.sort() you will end up with myString == None
2. Because there are several different ways to do common list operations it is best to learn them one at a time to avoid accidentally combining the syntax of two of them in ways that don't cause runtime errors but produce odd results.
3. remember that methods like sort modify the list so if you plan on using the original list for anything it is best to make a copy. It is important to do so in a way that does not simply create an aliase so originalList = myList[:] You can also try and stick to functions that return new lists like sorted instead of sort...
4. When reading from a file there is the possibility of unexpected input that can cause runtime errors. It is good practice to revisit the guardian pattern section when reading a file and try and make sure that the program can handle edge cases. In some cases a solution that will work well on properly formatted input is too simple to handle common situations. A common issue is when looking for a word in a line to split the string into a list of words. If the line is empty trying to iterate over an empty list will result in an index out of range error.


** Chapter 9 - Dictionaries
Otherwise known as a hash table. Items consist of unordered key:value pairs. You can find a value from a key easily but can't search for a key base on its value (you can reverse a dictionary using comprehensions though)
+ If you try to access an item with a key that is not in the dictionary you will get an exception.
+ len(myDict) wll return the number of key value pairs.
+ The in operator returns True if something is a *key* in the dictionary so myKey in myDict will let you know if myKey is in fact a keys
+ To see if something is a value in a dictionary you need to use vals = list(myDict.values()) and then use in on vals. The list function turns the result of the values method into a list that can then be checked for the value.
+ *The in operator uses a linear search on lists. As the list grows in length the search time goes up in proportion. For dictionaries Python uses a hash table so the search is in constant time.*
*** Dictionary as a set of Counter 9.1
There are several different ways we could count the occurrences of each letter in a string: You could create a value for each letter and then use chained conditional statement to increment each counter. You could create a list with an element for each letter and increment the value of the element for each occurrence. Or you could just use a dictionary. \
Some of the advantages of using a dictionary include only needing to create entries for the items being counted that exist as well as being able to search for an item using the hash rather than using a linear search through a list...
+ Dictionaries have the get(key, default) that returns the value of a key if it exists or default if it does not. *This is a Python idiom and is very common*
+ Looping and dictionaries: if you traverse a dictionary with a for statement you will traverse the *keys*
  If you want to order the contents of a dictionary you can make a list of the keys in the dictionary using the keys method. Sort the resulting list, and then loop through the list looking up each value based on the key extracted in order from the list of keys.
+ Advanced text Parsing: The basic implementation of a word count can't handle real prose as the split function uses whitespace leaving in punctuation marks attached to some words and our comparison does not take into account capitalization.
  - The translate method can be used on a string to delete specified characters.
  - python has a list of punctuation in string.punctuation in the string library
  - to remove the extra whitespace line.rstrip()
*** Debugging large datasets
+ Try scaling down the size you are testing - modify the program so that it is only running on the first 10 (or whatever number you want) lines of the file/elements. Once you have handled any errors you can increase the size
+ Check summaries and types - You can print out information like the size of a dictionary or list. The total sum of a list (if you have something to compare it to) You can also print out the type of a variable to make sure that it will not cause errors
+ Write self-checks - you can work in some basic sanity checks. For instance if you are calculating an average also print the high and low number to make sure that the average is between them. Also try comparing the results of different computations to make sure the results are consistent.
+ Format the output to make it easy to spot errors.
Spending a bit of time writing out test code can make the process of writing the production code easier.
*** Dictionaries lecture I, II 
Very powerful data structure. Unlike a list items are not ordered. Key-Value pairs. Known as associative Arrays in Perl/PHP, Properties or HashMaps in Java, and Property Bag in C#/.Net 
+ Dictionary Literals: use {} and contain a list of key:value pairs - myDict = {'name' : 9 , 'someOtherValue' : 10, 'soOn' : 'blah'}
+ example: count occurrences of a value. You can use a dictionary to add values as a key if the value is new or add to a count that is saved as the value for each key. One frustration is that you will need to run a check to see if the key already exists in the dictionary (use the in operator) as referencing a key that is not in the dictionary will throw an exception ?(why is this a problem? I would think that this is the behavior I would want from a datastructure rather than simply adding a key to the dictionary if I try to access a key that does not exist yet)
+ get method for dictionaries. The process of checking to see if a key is in a dictionary and if it is not add it with some default value is a common operation. The get method allows this to happen in one statement so instead of

 #+BEGIN_SRC python
  if name in counts:
      x = counts[name]
   else :
      x = 0
      #+END_SRC
  you can use
  =x = counts.get(name, 0)=
 it lets you avoid a traceback if name is not a key in counts.
#+BEGIN_SRC python
counts = dict()
names = ['csev', 'cwen', 'csev', 'xqian', 'cwen']
for name in names
    counts[name] = counts.get(name, 0) + 1
printcounts)
 #+END_SRC

*** Video Lecture Dictionaries III and Counting word frequency using a dictionary lecture
+ Counting Words in Text: The general pattern to count the words in a line of text is to split the line into words and then loop through the words and use a dictionary to track the occurrences of each word
  #+BEGIN_SRC python
  counts = dict()
  print('Enter a line of text')
  line = input('')

  words = line.split()

  print('Words:', words)

  print('Counting...')
  for word in words:
      counts[word] = counts.get(word, 0) + 1
  print('Counts', counts)
  #+END_SRC

+ Definite loops and dictionaries: Despite dictionaries not having an order to their elements we can write a for loop that goes through all of the keys and looks up the corresponding values
 counts = {a bunch of keys: with a bunch of values}
 for key in counts:
     print{key, counts[key]}

**** Dictionary methods
+ Retrieving lists of keys and values:
  - list(myDict) will return a list containing the keys from the dictionary
  - myDict.keys() will also return a list containing the keys
  - myDict.values() returns a list containing the values from the dictionary
  - myDict.items() returns a list of tuples each of which contains a key and the corresponding value.
\NOTE:\ If you use the keys() an values() methods right next to each other they will create lists in the same order. While the order is unpredictable it will not change between adjacent statements
+ Two iteration variables: When looping through a dictionary we need a variable for the key and a variable for the value
  #+BEGIN_SRC
for aaa,bbb in myDict.items():
    print(aaa, bbb)

#+END_SRC

This is a feature that is unique to Python...
+ Most common word in a file
  #+BEGIN_SRC python
name = input('Enter file:')
handle = open(name)

counts = dict()
for line in handle:
    words = line.split()
    for word in words:
        count[word] = counts.get(word, 0) + 1

bigcount = None
bigword = None
for word,count in counts.items():
    if bigcount is None or count > bigcount:
        bigword = word
        bigcount = count

print(bigword, bigcount)

#+END_SRC
*** Word Counting demonstration
IT is a good idea to put print and other tests in code as you write it so that you can find bugs as you write the code rather than trying to go back and figure out which part of a larger program is failing.

** Chapter 10 Tuples
*** Tuples Lecture Notes I, II
Tuples are like lists but are immutable like strings. They are indexed starting at 0. Instead of using [] when assigning values to a tuple you only need a comma separated list of values (if only one element append a comma so that python does not create a string), but it is common to  use () to indicate a tuple - though you still use [] when referencing an index. Of the methods and functions used with lists count and index can be used with tuples. Because tuples are immutable they can be used as keys for dictionaries. \
Tuples are more efficient than lists and if you only need to retrieve data a tuple is a faster and uses less memory. Tuples work well for temporary variables that will only be used briefly. Lists on the other hand are more often used when building up a datastructure.
+ Tuples can be used on the left-hand side of an assignment statement. (x,y) = (4, 'fred') you can return tuple from a function.
+ Tuples are comparable - The comparison goes through the items in order comparing each value to the corresponding value in the tuple being compared until Python finds an element that differs. This also works with < and > comparing index 0 and if they are equal comparing each subsequent element until one is larger or smaller. The rest of the values are not compared so (0, 1, 10000) is < (0, 2, 3). *How are comparisons between differing datatypes handled?*
**** Sorting lists of tuples
This can be used to get a sorted version of dictionary values.
sorted(myDict(items()))
this produces a sorted list of tuples sorted by the key.
+ to sort by values we need to create our own data structure. In this case we are creating a list of tuples sorted by value. To do this we can use a for loop that appends to a new list tupples with the value first and then the key. We can then sort the new list and have the contents of the dictionary sorted by value.
#+BEGIN_SRC python
myDict = {'a':10, 'b':1, 'c':22}
tmp = list()
for k, v in myDict.items()
    tmp.append( (v, k) )
# This writes tuples that consist of the value followed by the key from the dictionary to the list tmp
print(tmp)
# this will print out the value followed by the key in no perticular order
tmp = sorted(tmp, reverse=True)
print(tmp)
# This will sort tmp by value in decending order
#+END_SRC

+ To print out the 10 most common words from a file:
#+BEGIN_SRC python
fhand = open('romeo.txt')
counts = dict()
for line in fhand:
    words = line.split()
    for word in words:
        counts[word] = counts.get(word, 0 ) + 1 

lst = list()
for key, val in counts.items():
    newtup = (val, key)
    lst.append(newtup)

lst = sorted(lst, reverse=True)

for val, key in lst[:10] :
    print(key, val)
#+END_SRC
+ short version to sort a dictionary  by value 
print( sorted( [ (v,k) for k,v in myDict.items()]))
this use lambdas and list comprehensions \  
the statement inside of the square brackets creates a list dynamically without assigning it to a variable. 
*** Sorting dictionary by values with tuples lecture notes
tmp = list()
for k,y in dictionary.items() :
    newtup = (v,k)
    tmp.append(newtup)

tmp = sorted(tmp)

*** Tuples chapter notes
Because tuples are immutable they can be used as kkey values in dictionaries. They are also comparable so they can be sorted and hashable. 
+ a tuple is a comma-seperated list of values. It is common to enclose tuples in parentheses to make the code more readable. 
+ To create a single element tuple you need to include a following comma so 
=myTuple = ('a',)=
withou the comma python would evaluate ('a') as a string
+ An empty tuple can alo be created with the tuple() function: =myTuple = tuple()=
+ If the argument of the tuple function is a sequence (string, list, or tuple)the tuple will contain the elements of the sequence =myTuple = tuple('string')creates mytuple with elements ('s', 't', 'r', 'i', 'n', 'g')
+ best not to use tuple as a variable name as it is the name of the constructor function. 
+ Some list operators also work with tuples. Tuple elements can be refered to using [] The slice operator works to select a range of elements. 
+ While you can't change the value of an element of a tuple you can replace one tuple with another one. Like a string...
+ When comparing collections python tarts by comparing the first element from each sequence. Only if they are equal does python check the next element (much like putting words in alphabetical order) This also applies to the sort function 
+ Pattern for working with sequences *DSU*
- Decorate a sequence by building a list of tuples with one or more sort keys preceding the elements from the sequence 
- Sort the list of tuples using Python's built in sort
- Undecorate by extracting the sorted elements of the sequence

As an example to sort a lit of word from longet to shortest.
#+BEGIN_SRC python 
txt = 'but soft what light in yonder window breaks'
words = txt.split()
t = list()
for word in words:
    t.append(len(word), word)

t.sort(reverse=True)

res = list()
for length, word in t:
    res.append(word)
#+END_SRC

**** Tupple assignment
In Python you can have a tuple on the left side of an assignment statement. This allows you to assign more than one variable at a time when the left side is a sequence. In these cases it is standard to ommit the () so if myList has 3 elements =x, y, z = myList= will assign myList[0] to x, myList[1] to y.... This can be also used to swap the value of two variables do we can do =a,b = b, a=
+ In this case the left side is a tuple of variables while the right side of the assignment is a tuple of expressions
+ the number of varuables on the left side if the assignment must match the number of values on the right
+ The right side of the assignment can be any type of sequence - list, string, or tuple. so if =addr = 'some@email.com' \  uname,domain = addr.split('@')= will split an email address into the username and domain. 
**** Dictionaries and tuples
Dictionaries have a method called items that returns a list of tupples. Each tuple is a key value pair. The elements are in no order when placed in the list but can be sorted by traversing the list and comparing the tuples. If we want to sort by the value rather than the key we will need to reverse the sequence by writing to a new list of tuples with the values and the key reversed. The new list can then be sorted. 

+ To traverse the eys and values of a dictionary in a single loop 
for key, val in list(myDict.items()):
    print(val, key)
  
This loop has two iteration variables because items() returns a list of two item tuples. For each iteration of the loop both key and val are iterated (/aren't they a tuple in and of themselves because of how they are assigned?/) 

**** Tuples as keys in dictionaries 
If we want to use a composit key in a dictionary we need to use tuple rather than lists. Because a dictionary is a hash map we need to use the hashable tuple rather than the mutable list. \  
An example of a case where we would use a composit key is in a telephone directory where we want the number (the value) associated with the firstname/lastname pair. so if we have variables first, last, and number we can assign them to a dictionary with =directory[last,first] = number= \  
To traverse this directory with a tuple assignment
for last, first in directory:
    print(first, last, directory[last,first])

**** sequences
Most of the teqniques in this chapter can be aplied to other compound structures besides lists of tuples - they work with tuples of tuples, lists of lists and tuples of lists? apparently... Instead of handling each case individualy we will look at sequences of sequences in general.  
+ Strings have several limitations, they are immutable and can only contain characters. If you will need to change individual characters a list of characters may be the better option.
+ Tuples have some advantages over lists
- Tuples can be easier to create than a list: for example in return statements. 
- In cases where you need an immutable type such as dictionary keys
- When passing a sequence to a function tuples reduce unexpected behaviors due to aliasing 
- While tuples don't have methods like sort and revere the functions sorted and reversed can be used on any sequence to return a new sequence with the order altered. 

Compound datastructures can cause error if the programmer looses track of the shape of the structure 

** Regular expressions
[[file:~/Dropbox/notes/python-regex.md::REGEX from python for everybody][<Notes for this chapter in REGEX for Python notes>]]

** Chapter 12 Networked Programs
*** Notes from text
    You can communicate with a wide range of servers using sockets. As sockets is handling the low level connection, you just need to make sure that you send and recieve code according to the protocol the server is using. 

**** HTTP 
     Python has built in support for common networking protocols called sockets. Interface is much like the one for files, but is 2-way. 
     Protocols tell the software who is supposed to talk when, and describes the format used on the wire. 
**** Reading binary files
     Since this is the most common protocol there is a library to make implementing HTTP easier.
     + HTTP uses byte objects instead of strings, use encode() and decode() to convert.
     + you can use b'' to specify a variable be stored as a byte object instead of encode()
     + To recieve data (like an image) we can store it in a string while the program is running, Then remove the HTTP header and save the data in a file.
    + flow control and buffering can be messed with when working at this low level.
    
    Rather than manually send and recieve data through sockets we can use urllib. You only need to specify the url and can treat it like reading any other file as urllib handles retrieving it. 
    To retrieve and decode a file
    #+BEGIN_SRC python
    import urllib.request 

    fhand = urllib.request.urlopen('http://data.pr4e.org/romeo.txt')
    for line in fhand:
        print(line.decode.strip())
    #+END_SRC
    You don't need to worry about the HTTP headers as urllib removes them automagically.
**** Parsing HTML and scraping the web
+ simple way to find what you are looking for in a bunch of HTML files is with REGEX
+ unfortunately many webpages are poorly coded so using a html parsing library like BeautifulSoup yields better results.
+ multiple libraries available for the task,
*** Video Lecture Part 1, 2
**** How networking works - This will start at the transport layer
We will assume the lower levels are working and we have a socket connection to the networked resource we are trying to communicate with. A TCP port number, by convention, matches the type of service we are trying to connect to. Python ha built in support for TCP sockets. =import socket= to use in your script. You then need to create a sockket object with =mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)= and then associate it with a connection =mysick.connect( ('data.py4e.org', 80) )= This creates a stream socket rather than a block socket.

At this point we have a connection so we move on to the application layer. The *Application Protocol* outlines how the communication procedes. Possible protocols include HTTP (the one we will mostly be looking at), mail, gopher (yea right), ftp (also not common these days) When you click on a link the browser makes a connection to port 80 on the server specified by the URL and sends a GET request. The server responds with the document requested. A get request needs to be formated as GET http://some.host.com HTTP/1.0

**** Lets write a browser \  

     #+BEGIN_SRC python 
         import socket 

         mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         mysock.connect(('data.pr4e.org', 80))
         cmd = 'GET http://data.pr4e.org/romeo.txt HTTP/1.0\n\n'.encode()
         mysock.senc(cmd)

         while TRUE:
             data = mysock.recv(512)
             if (len(data) < 1):
                 break
             print(data.decode())
         mysock.close()
     #+END_SRC
     
The mysock.connect may throw an exception if there is a problem with network connectivity. The GET request contains a blank line due to the protocol requiring it. We then create a receive connection that stays open until we get a response of length 0 indicating the transmission is over. In the response there will be a blank line between the header portion of the response and the data. The data.decode will work on 'plain text' but if the url we request points to a binary file we would need to put it in a file and open it

**** Worked Sample code 
/example in code 3 folder/
This seems like a copy of the material in video 3

**** Video lecture 4 Characters and strings 

Character encoding is more complex than ASCI. UNICODE is a lot more complex but UTF-8 abstracts most of that away. UTF-32 is huge, UTF-16 is used on some countries, but UTF-8 is dynamicaly sized and is compatible with ASCI. UTF-8 can represent UTF-32 is needed. In Python 2 unicode and string were different but in Python 3 strings are Unicode and bytes are the outlier.
When we are receiving data from outside sources strings may be in byte format so we need to be ready for non-UTF string. That is why we use decode on the information received over a socket. In some situations we may need to encode what we are sending out in some format other than the default...
In the code block above we used the encode() method on the string containing the GET command, the default encoding is UTF-8 though we could give the encode method arguments that specify other encoding types. When we receive data back we need to use the decode method to turn the external byte array (UTF-8) data into a Python string before printing.

**** Video 5 urllib

Because of how common working with http servers has become Python3 has a library to make tasks like retrieving a html document even easier.
#+BEGIN_SRC python

import urllib.request, urllib.parse, urllib.error

fhand = urllib.request.urlopen('http://data.pr4e.org/romeo.txt')
for line in fhand:
    print(line.decode().strip())
#+END_SRC

 This code retrieves the html document into an object that acts like a file handle. We can then loop through the object and read out each line and decode it. The default behavior of urlopen is to strip out the headers, though we can keep them if necessary.

 To do a word count on a html document on a server

 #+BEGIN_SRC python

 import urllib.request, urllib.parse, urllib.error

 fhand = urllib.request.urlopen('http://data.pr4e.org/remeo.txt')

 counts = dict()
 for line in fhand:
     words = line.decode().split()
     for word in words:
         counts[word] = counts.get(word, 0) + 1
 print(counts)
 #+END_SRC

l

**** Video 6 HTML parsing
What do you do with webpages once you have retrieved them.
+ Webscraping - when a program pretends to be a browser and retrieves web pages, extracts information, and then looks at more web pages
+ spidering - when your program follows the links on the pages you scrape to find the next pages to scrape.

Why scrape?
+ Data collection, what pages are linked together?
+ Retrieve your own data without needing an export tooltips
+ Monitor a site for new information
+ creating a search engine

Some web pages don't like being scraped and will try and block you (or shut down accounts if you have one) Often html is creative in ways that make using regex to parse them difficult. The BeautifulSoup library from www.crummy.com handles parsing html for you.
As this library is an important one I will have more notes on it in a dedicated file.
**** Worked example BeautifulSoup

*** exercises
**** Explore HTTP Request Response
reminds me of a how to CTF Challenge
**** Scraping soup

** Chapter 13 Using Web services
*** Video Web Services Part 1
HTTP became popular so it has become a way for applications to exchange data. The machine readable formats we will cover are xml and JSON (not covered TOML, YAML) The 'wire format' provides a way for programs that may use different internal representations for data to have an agreed upon format. The data is serialized into the wire format for transmission and then de-serialized on the other end.
+ JSON is probably the more popular, it is simpler than xml
+ XML is used as a document format by some programs.
*** Video Web Services 2 - XML
eXtensible Markup Language Probably caught on because it looked a bit like HTML and people thought <> looked neat
+ Start tag <someTag>
+ end tag </someTag>
+ Attribute <tag myAttr="urpy"/>
+ self closing tag </someTag>
XML is fairly unforgiving when it comes to syntax.
+ XML tends to ignore whitespace, line breaks are ignored, indentation is for humans.
+ The structure of nodes is important, parent and child tags will matter when parsing the document
+ XML can be understood as a tree, one root tag with branching child tags with their own children and siblings.
+ content of tags is modeled as child of the tag it is contained in.
+ attributes are also children of the tag they are attached to and therefore siblings of the textual data in the tag they modify.
+ you can have multiple attribute for a tag but only one text node per tag.
XML can also be parsed by tracking out the path from one node to the root of the document.
*** Worked example XML
+ Element tree will raise exceptions if there is a problem with the XML.
+ So try except /I must accept/
*** Web Services 3: XML Schema
+ Describes the legal format of XML documents.
+ Validates XML between two applications.
+ XML Schema Contract is in a format of XML.
+ Many XML Schema languages
+ We are looking at the W3C Schema spec (also called .XSD for the file-type)
So I think what is going on here is the schema outlines the types of tags, if the element is required, type of data, proper formatting for date and time(yyyy-mm-ddTGMT) and the other information a XML validation program needs to check the XML document.
+ To work with XML in Python we are using xml.etree.ElementTree
*** Web Services 4: JSON & Discovering JSON
+ More common than XML these days.
+ datastructure mimics the way languages like JS and Python represent data
+ JSON is not a standard, defined by the guy who wrote JS the good parts (I should read that book)
+ uses {} to enclose key:value pairs
+ Python works with JSON as nested lists and dictionaries instead of as a complex object as XML is represented.
+ JSON is very similar to other ways data has been exchanged by different software
+ was published by the inventor so he could claim it wa a standard and use it at his day job
*** Web Services 5 SOA, JISC e-Framework
Service Oriented approach
+ Designing software around networked services. One program does not do everything, instead it provides an interface to access other software
+ Often grows organically out of needs of the moment
+ SOA provides a service layer between systems.
+ Avoids extra effort in trying to get micro-services to talk to each other
+ data as a service, probably using REST API
*** Web Services 6 GeoJSON, Web Service 7 Twitter, Worked Examples
+ write software that consumes data provided by an API
+ start by reading the documentation that explains the URL and the encoding rules for the request.
+ trial and error and practice is the only way to learn how to do this stuff
+ Google offers less of their geolocation stuff for free, I should use my credits while they are still good.
+ In a url + is space and % is ,
+
*** Notes from book

**** 13.2 Parsing XML
  simple program to parse XML and extract some data elements 
     #+BEGIN_SRC python
import xml.etree.ElementTree as ET

data = '''
<person>
  <name>Chuck</name>
  <phone type="intl">
    +1 734 303 4456
  </phone>
  <email hide="yes" />
</person>'''

tree = ET.fromstring(data)
print('Name:', tree.find('name').text)
print('Attr:', tree.find('email').get('hide'))
     #+END_SRC

+ fromstring convert the string representation of XML into a tree of XML elements. Once the XML is in tree format we can use a series of methods to extract the data we are looking for.
+ find searches the XML tree and retrieves the elements that match the specified tag. 

  A XML parser like ElementTree has the advantage of allowing us to ignore the complexity of proper XML syntax. In more complex situations this can be very important. /I would not like to need to write a regex to extract data/ 

**** 13.3 Looping Through Nodes 
     When XML has multiple nodes we need a loop to process all of them. The following code loops through all of the user nodes
     #+BEGIN_SRC python
import xml.etree.ElementTree as ET

input = '''
<stuff>
  <users>
    <user x="2">
      <id>001</id>
      <name>Chuck</name>
    </user>
    <user x="7">
      <id>00</id>
      <name>Brent</name>
    </user>
  </users>
</stuff>'''

stuff = ET.fromstring(input)

lst = stuff.findall('users/user')
print('User count:', len(lst))

for item in lst:
    print('Name', item.find('name').text)
    print('Id', item.find('id').text)
    print('Attribute', item.get('x'))

    #+END_SRC

+ findall retrieves a Python list of subtrees that represent the user structure in the XML tree 
+ it is necessary to include all parent level elements in the findall statement except for the top level element or Python will not find any nodes. The following would not find any users 
    #+BEGIN_SRC python
lst = stuff.findall('user')
print('User count:', len(lst))
     #+END_SRC

**** 13.4 JSON 
     Since JSON is based on JS and JS was influenced by Python there are similarities between the JSOn format and Python lists and dictionaries. 
+ Unlike XML in JSON we don't have attributes, just a series of key value pairs. 
+ Instead of a top level element the tart of a JSON object is marked by {}
+ Used for data exchange between programs as it maps well to the basic data structures 
+ JSON can be contructed by nesting dictionaries and lists.
+ JSON contains fewer details than XML so we need more knowledge in advance about the structure of the data we are getting.

#+BEGIN_SRC python
import json 

data = '''
[
  { "id" : "001",
    "x" : "2",
    "name" : "Chuck"
  } ,
  { "id" : "009",
    "x" : "7",
    "name" : "Brent"
  }
]'''

info = json.loads(data)
print('User count:', len(info))

for item in info:
    print('Name', item['name'])

print('Id', item['id'])
print('Attribute', item['x'])

#+END_SRC
+ Because json.load() returns a Python list we can simply access it like any list of dictionaries 

**** 13.6 API 
     Using HTTP we can send data between applications and we can represent data on the wire using XML or JSON /these days JSON/ To define the services available to other applications and how to acces them we define an API. 
+ When the functionality of a program includes access to services provided by other programs we use *Service-oriented architecture* (SOA) 
+ SOA has many advantages including that we only maintain one copy of the data and that the owner of the data maintains control. One disadvantage is that performace can suffer multiple bottlenecks.
+ It is common to require the use of an API key to make use of a service that is exposed to the web. In some cases even OAuth. For these cases there are a range of libraries available 

**** 13.9 Google geocoding web service 




** Chapter 14 Object Oriented Python
*** Video 1 Python Objects
+ Focus of the class is not OOP so this chapter is a terminology only chapter.
+ Objects provide a way of abstracting away details that beginners like me don't need to know to use the libraries/objects. Basic collection types are objects /actually anything that has methods/

definitions:
- Class: A template
- Method or Message: a defined capability of a class
- Field/attribute: A bit of data in a class
- Object/Instance: An instance of a class

*** Video 2
+ Class is a reserved keyword
**** A Sample Class
#+BEGIN_SRC python
class PartyAnimal:
    x = 0

    def party(self):
        self.x = self.x + 1
        print("So far".self.x)

an = PartyAnimal()

an.party()
an.party()
an.party()

#+END_SRC
+ Methods are like functions but are part of a method and are not valid outside of the method
+ self is an alias of the instance of the class that is automatically passed to the methods of the class when the instance of the object calls the method. /Basically you are telling the method that it is to act on the instance that called it/
+ Before you use a class you need to construct an instance of it.
+ the dir() function lists an objects methods telling you what its capabilities are.
+ y = 'Hello there' actually creates an object of type string and then assigns the string to the new object.
+ since you can use type() and dir() on classes that you create it is a good idea to write doc strings.

*** Video 3, 4
+ Objects are created, used, and discarded
+ Objects have blocks of code called constructors and detructors that do exactly what they sound like they should do. You almost never run into destructors in Python though, it does its own garbage collection.
#+BEGIN_SRC python
class PartyAnimal:
    x = 0
    name = ""
        def __init__(self, name):
            self.name = name
            print('This is the constructor')

        def party(self):
            self.x = self.x + 1
            print('I am a normal method and have been called ', self.x)

        def __del__(self):
            print('I am the destructor, I am a dunder method')

    class FootballFan(PartyAnimal):
        point = 0
        def touchdown(self):
            self.points = self.points + 7
            self.party()
            print(self.points, 'points', self.party, 'drinks')

    s = PartyAnimal('Butthead')
    s.party()

    j = FootballFan('Beavis')
    j.party()
    j.touchdown()
#+END_SRC

+ We can extend or subclass an existing class. The new class inherits from the existing or parent class.
+ The subclass will have the methods and attributes of the parentclass as well as any new ones you add.
+ Because FootballFan is a subclass of PartyAnimal when we create j (Beavis) it will use the PartyAnimal constructor. j has all the methods and variables as s
+ /Everything in Python is an object so OOP is inherent in the way Python works/

*** Reading
Once a code base reaches a certain size various methodologies like OOP become important to both organize the codebase and provide a mental model for the programmers trying to work with the code.

** Chapter 15 Databases
Focus will be on SQLite as it is built in to Python.
+ SQLite is designed to be embedded into other applications to store and retrieve data.
+ https://github.com/sqlitebrowser/sqlitebrowser/wiki
+ A database has a more defined structure than the basic Python structures like dictionaries and lists.
+ When creating a table in a SQL database we need to define in advance the name and datatype of the column. This predefined structure allows the database software to optimize the data storage and retrieval process beyond what more general structures can.
+ to create a database file and a table named Tracks with two columns:

    #+BEGIN_SRC python
    import sqlite3

    conn = sqlite3.connect('music.sqlite')
    cur = conn.cursor()

    cur.execute('DROP TABLE IF EXISTS Tracks')
    cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')

    conn.close()
  #+END_SRC
+ the cursor is like a file handle.
+ once the cursor object is created we can use the execute() method to make changes to the contents of the database
+ Once the database and table are set up we can insert data
+ commit() does the actual write operation. /I am guessing that execute writes the commands to the cursor object and commit() applies the data in the structure to the database/
#+begin_src python
import sqlite3

